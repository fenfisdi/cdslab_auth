from datetime import datetime, timedelta

from fastapi import APIRouter, status

from source.dependencies.qr_deps import validate_qr
from source.dependencies.responses import set_json_response
from source.dependencies.token_deps import generate_token_jwt
from source.dependencies.user_deps import verify_password
from source.interfaces.user_interface import UserInterface
from source.models.user import PreAuthenticatedUser, AuthenticatedUser
from source.utils import LoginMessage, UserMessage


router_of_authentication = APIRouter()


@router_of_authentication.post("/loginAuthentication", status_code=status.HTTP_200_OK)
async def login_auth(pre_authenticated_user: PreAuthenticatedUser):
    """
        Validate user information at login time

        Parameters
        ----------
        - pre_authenticated_user: dict
            email associated to the user

        Returns
        ----------
        - Method
            - key_qr: str
                Hash to match second authentication factor

            - email:str
                Email associated to the user

        Raises
        ----------
        - HTTPException
            If passwords don't match

        - HTTPException
            If user doesn't exist
    """
    retrieved_user = UserInterface.retrieve_user(
        email=pre_authenticated_user.email
    )

    if retrieved_user:
        is_equal = verify_password(pre_authenticated_user.password,
                                   retrieved_user["hashed_password"])
        if is_equal:
            data = {
                "key_qr": retrieved_user.get("key_qr"),
                "email": retrieved_user.get("email"),
            }
            return set_json_response(
                LoginMessage.logged,
                status.HTTP_200_OK,
                data
            )

        return set_json_response(
            LoginMessage.invalid_user,
            status.HTTP_404_NOT_FOUND
        )
    return set_json_response(
        UserMessage.not_found,
        status.HTTP_404_NOT_FOUND
    )


@router_of_authentication.post("/qrAuthentication",
                               status_code=status.HTTP_200_OK)
async def qr_auth(authenticated_user: AuthenticatedUser):
    """
        Validate if qr and the user input match the 2FA and
        generates a token

        Parameters
        ----------
        - **email**: str
            User email

        - **qr_value**: int
            Code generated by Google Authenticator

        Returns
        ----------
        - **response**: str
            Token

        Raises
        ----------
        - **HTTPException**:
            If token is invalid or email doesn't exist

        - **HTTPException**:
            If key_qr does't match the expected value
    """
    is_valid = validate_qr(
        {"email": authenticated_user.email},
        authenticated_user.qr_value
    )

    if is_valid:
        retrieved_user = UserInterface.retrieve_user(
            email=authenticated_user.email)
        payload = {
            "expires": str(datetime.utcnow() + timedelta(hours=24)),
            "id": str(retrieved_user["_id"]),
            "role": str(retrieved_user["role"]),
            "email": str(retrieved_user["email"]),
        }

        token = generate_token_jwt(payload)
        if token:
            return set_json_response(
                LoginMessage.logged,
                status.HTTP_200_OK,
                dict(token=token)
            )
        return set_json_response(
            LoginMessage.token_error,
            status.HTTP_404_NOT_FOUND
        )
    return set_json_response(
        LoginMessage.invalid_qr,
        status.HTTP_404_NOT_FOUND
    )
