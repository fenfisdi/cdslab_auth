from typing import List

from fastapi import APIRouter, status
from starlette.status import (
    HTTP_200_OK,
    HTTP_400_BAD_REQUEST
)

from src.models import (
    LoginUser,
    OTPUser,
    RecoverUser,
    SecurityCode,
    SecurityQuestion
)
from src.services import UserAPI
from src.use_cases import SecurityUseCase
from src.utils import LoginMessage
from src.utils.response import UJSONResponse
from src.utils.security import random_number_with_digits

authentication_routes = APIRouter()


@authentication_routes.post("/login", status_code=status.HTTP_200_OK)
def login_auth(user: LoginUser):
    """
        Validate user information at login time

        Parameters
        ----------
        - pre_authenticated_user: dict
            email associated to the user

        Returns
        ----------
        - Method
            - key_qr: str
                Hash to match second authentication factor

            - email:str
                Email associated to the user

        Raises
        ----------
        - HTTPException
            If passwords don't match

        - HTTPException
            If user doesn't exist
    """
    response, is_invalid = UserAPI.validate_credentials(user.dict())
    if is_invalid:
        return response

    data = response.get('data')
    data['email'] = user.email

    return UJSONResponse(LoginMessage.logged, HTTP_200_OK, data)


@authentication_routes.post("/login/otp", status_code=status.HTTP_200_OK)
def login_otp_auth(user: OTPUser):
    """
        Validate if qr and the user input match the 2FA and
        generates a token

        Parameters
        ----------
        - **email**: str
            User email

        - **qr_value**: int
            Code generated by Google Authenticator

        Returns
        ----------
        - **response**: str
            Token

        Raises
        ----------
        - **HTTPException**:
            If token is invalid or email doesn't exist

        - **HTTPException**:
            If key_qr does't match the expected value
    """
    response, is_invalid = UserAPI.find_user(user.email)
    if is_invalid:
        return response

    otp_code = SecurityUseCase.transform_otp_code(user.otp_code)
    response, is_invalid = UserAPI.find_otp_code(user.email)
    if is_invalid:
        return response

    data = response.get('data')
    auth_code = SecurityUseCase.transform_otp_code(data.get('otp_code'))
    if auth_code != otp_code:
        return UJSONResponse(LoginMessage.invalid_qr, HTTP_400_BAD_REQUEST)

    data = {
        'token': SecurityUseCase.encode_token_access(dict(email=user.email))
    }
    return UJSONResponse(LoginMessage.logged, HTTP_200_OK, data)


@authentication_routes.post('/login/recovery_code')
def create_security_code(email: str):
    response, is_invalid = UserAPI.find_user(email, False)
    if is_invalid:
        return response

    security_code = random_number_with_digits(6)
    response, is_invalid = UserAPI.save_security_code(email, security_code)
    if is_invalid:
        return response

    # TODO: Send Email


@authentication_routes.post('/login/validate_code')
def validate_security_code(user: SecurityCode):
    response, is_invalid = UserAPI.find_user(user.email, False)
    if is_invalid:
        return response

    response, is_invalid = UserAPI.find_security_code(user.email)
    if is_invalid:
        return response

    if user.security_code == response.get('data').get('security_code'):
        return UJSONResponse(LoginMessage.success_code, HTTP_200_OK)
    return UJSONResponse(LoginMessage.invalid_code, HTTP_400_BAD_REQUEST)


@authentication_routes.post('/login/recover_password')
def recover_password(user: RecoverUser):
    response, is_invalid = UserAPI.find_user(user.email)
    if is_invalid:
        return response

    response, is_invalid = UserAPI.update_password(
        user.dict(exclude={'verify_password'})
    )
    if is_invalid:
        return response

    return UJSONResponse('updated', HTTP_200_OK)


@authentication_routes.get('/login/security_question')
def find_security_questions(email: str):
    response, is_invalid = UserAPI.find_user(email)
    if is_invalid:
        return response

    response, is_invalid = UserAPI.find_security_questions(email)
    if is_invalid:
        return response

    data = response.get('data')

    return UJSONResponse(LoginMessage.found_question, HTTP_200_OK, data)


@authentication_routes.post('/login/security_questions')
def recover_otp(
        email: str,
        security_questions: List[SecurityQuestion]
):
    response, is_invalid = UserAPI.find_user(email)
    if is_invalid:
        return response

    response, is_invalid = UserAPI.find_security_questions(email)
    if is_invalid:
        return response

    questions = response.get('data')
    valid = list()
    for question in security_questions:
        valid_question = next((
            in_question for in_question in questions
            if in_question.get('question') == question.question
        ), None)
        if valid_question is None:
            valid.append(False)
            continue
        if valid_question.get('answer') == question.answer:
            valid.append(True)
        else:
            valid.append(False)

    if not all(valid):
        return UJSONResponse(LoginMessage.invalid_answers, HTTP_400_BAD_REQUEST)

    response, is_invalid = UserAPI.find_otp_code(email)
    if is_invalid:
        return response
    data = response.get('data')
    data['email'] = email
    data['url'] = SecurityUseCase.create_otp_url(data.get('otp_code'), email)
    return UJSONResponse('any', HTTP_200_OK, data)
