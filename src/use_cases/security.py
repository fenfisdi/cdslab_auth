from typing import Tuple, Union, Optional

from jose import jwt, JWTError
from pyotp import TOTP, random_base32
from starlette.status import HTTP_400_BAD_REQUEST

from src.config import secrets
from src.services import UserAPI
from src.utils.date_time import DateTime
from src.utils.messages import LoginMessage
from src.utils.response import UJSONResponse


class SecurityUseCase:

    @staticmethod
    def encode_token_email(email: str) -> str:
        data = {
            'email': email,
        }
        return jwt.encode(
            data,
            secrets.get('SECRET_KEY'),
            secrets.get('ALGORITHM')
        )

    @staticmethod
    def encode_token_access(data: dict) -> str:
        data['exp'] = DateTime.expiration_date(hours=1)
        return jwt.encode(
            data,
            secrets.get('SECRET_KEY'),
            secrets.get('ALGORITHM')
        )

    @staticmethod
    def decode_token(token: str) -> Tuple[Union[dict, None], bool]:
        """
            Extract data from token and return a key pair

            Parameters
            ----------
            token: str
                A string generated by the email_access_token function

            Returns
            ----------
            decode_email: class applicant_user
                Key pair for the associated email
        """
        try:
            data = jwt.decode(
                token,
                secrets.get('SECRET_KEY'),
                secrets.get('ALGORITHM')
            )
            if not data.get('email'):
                return None, False
            return data, True
        except JWTError:
            return None, False

    @staticmethod
    def create_otp_code():
        return random_base32()

    @staticmethod
    def create_otp_url(otp_code: str, email: str):
        return TOTP(otp_code).provisioning_uri(email)


class ValidateOTPUseCase:

    @classmethod
    def handle(
            cls,
            email: str,
            otp_code: str
    ) -> Tuple[Optional[UJSONResponse], bool]:
        """
        Validate OTP code from user,

        :param email:
        :param otp_code:
        :return:
        """
        response, is_invalid = UserAPI.find_user(email, True)
        if is_invalid:
            return response, True

        response, is_invalid = UserAPI.find_otp_code(email)
        if is_invalid:
            return response, True

        data = response.get('data')
        auth = TOTP(data.get('otp_code'))
        if auth.verify(otp_code):
            return UJSONResponse(
                LoginMessage.invalid_qr,
                HTTP_400_BAD_REQUEST
            ), True
        return None, False
